from inspect import getmembers
from math import exp
from random import choice
from pypokerengine.engine.poker_constants import PokerConstants
from pypokerengine.players import BasePokerPlayer
from pypokerengine.utils.card_utils import gen_cards, estimate_hole_card_win_rate

class RaisedPlayer(BasePokerPlayer):
    INFORMATION = {'number_of_players': 2, 'number_of_simulations': 1000}

    # TODO: update exploration of game tree via minimax
    def explore_game_tree(self, cards, round_state, actions):
        return choice(list(filter(lambda x: x != None, actions)))

    def declare_action(self, valid_actions, hole_card, round_state):
        fold_action, raise_action, call_action = list(map(lambda valid_action: valid_action['action'], valid_actions)) + [None] * (3 - len(valid_actions))

        current_round = round_state['street']

        # mathematically increasing function (approaches 0 as x gets more and more negative and 1 as x gets more
        # and more positive)
        sigmoid_function = lambda x: exp(x) / (exp(x) + 1)

        # weights for deciding whether to fold based on sigmoid function (inverse function of the game round)
        weights = {member[0]: sigmoid_function(member[1] - 2) for member in getmembers(PokerConstants.Street())[0: 6]}

        community_card = round_state['community_card']

        # calculated win rate generated by PyPoker based on hole cards and community cards (if the round is
        # not a preflop)
        win_rate = estimate_hole_card_win_rate(RaisedPlayer.INFORMATION['number_of_simulations'],
                                               RaisedPlayer.INFORMATION['number_of_players'],
                                               gen_cards(hole_card + community_card))

        # if the probability of winning is less than a certain cutoff based on weights calculated by the sigmoid
        # function then the agent choose to fold, otherwise it explores the game tree to choose whether to call or
        # raise
        if win_rate < weights[current_round.upper()] and fold_action != None:
                return fold_action
        else:
                remaining_actions = [raise_action, call_action]
                return self.explore_game_tree(hole_card, round_state, remaining_actions)

    def receive_game_start_message(self, game_info):
        pass

    def receive_round_start_message(self, round_count, hole_card, seats):
      pass

    def receive_street_start_message(self, street, round_state):
      pass

    def receive_game_update_message(self, action, round_state):
      pass

    def receive_round_result_message(self, winners, hand_info, round_state):
      pass


def setup_ai():
  return RaisedPlayer()